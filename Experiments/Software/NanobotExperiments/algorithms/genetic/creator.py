"""
.. module:: genetic.creator
    :platforms: Unix, Windows
    :synopsis: Experimental creator used by the Genetic Algorithm (GA)

.. moduleauthor:: Graham Keenan (Cronin Lab 2019)

"""
# System imports
import time
import random
import logging
import numpy as np
from pathlib import Path
from typing import List, Dict

# Platform imports
from .genetic import GA
import nanobot.constants as cst
from modularwheel.utils import read_json, write_json

# Locations
HERE = Path('.').absolute()
DATA = HERE.joinpath('..', '..', 'data')
GENETIC = DATA.joinpath('genetic')


class GeneticCreator:
    """
    Class for creating generations to be used with the GA algorithm
    Creates a generation of experiments to be conducted

    Args:
        info (Dict): Info from the platform's info file
    """

    def __init__(self, info: Dict):
        # Experiment info
        self.info = info

        # Initialise a logger
        self.logger = logging.getLogger('GeneticCreator')
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s::%(levelname)s - %(message)s',
            datefmt='%d-%m-%Y %H:%M',
            force=True
        )

        # Parameters for the GA
        self.params = info["GA"]

        # Root XP path
        self.xp_path = self.generate_xp_folder()

        # Set the seed and initialise the GA
        self.set_random_seed()
        self.algorithm = GA(**self.params["params"])

        # Average fitnesses for graph
        self.average_fitnesses = []

    def set_random_seed(self):
        """
        Sets the random seed from the info file
        Helps to seed the algorithm
        """
        random.seed(self.info[cst.SEED])
        np.random.seed(int(self.info[cst.SEED]))

    def generate_xp_folder(self):
        """
        Creates a root folder for the experiment
        """
        path = GENETIC.joinpath(self.info[cst.TITLE], str(self.info[cst.SEED]))

        if not path.exists():
            path.mkdir()

        return path

    def create_population(self) -> List[float]:
        """
        Creates a new population of values for a generation

        Returns:
            pop (List): List of values for the generation
        """

        return self.algorithm.get_next_population()

    def convert_pop_to_dict(self, pop: List[float]) -> Dict:
        """
        Converts a population of values into a dictionary for use
        with the platform's pumps

        Args:
            pop (List): List of values generated by the algorithm

        Returns:
            ratio (Dict): Dictionary containing the pump names and values from
                            the population
        """

        static = self.params["static_reagents"]
        varied = self.params["varied_reagents"]
        varied_dict = {reagent: vol for reagent, vol in zip(varied, pop)}

        return {**varied_dict, **static}

    def create_generation(self, n_gen: int):
        """
        Creates a generation folder, populated with experiments
        Algorithm generates parameters for each experiment
        Random parameters at first then algorithmically chosen onces thereafter

        Args:
            n_gen (int): Current generation number
        """
        # Creates a population of experiments for the generation
        population = self.create_population()

        # Creates the folder for the generation
        gen_folder = self.xp_path.joinpath(f'{n_gen:04d}')
        gen_folder.mkdir()

        self.logger.info(f'Creating generation: {gen_folder.as_posix()}')

        # Iterates through the population
        # creating a folder and params file for each xp
        for pos, pop in enumerate(population):
            # Creates the xp folder
            xp_folder = gen_folder.joinpath(f'{pos:04d}')
            xp_folder.mkdir()

            # Converts the population for this XP into a dictionary
            params = self.convert_pop_to_dict(pop)
            params_file = xp_folder.joinpath(cst.PARAMS_FILE)
            xp_log = xp_folder.joinpath(cst.XP_LOG)

            # Checks if a parameter file exists and checks the values
            # for this seed number match
            if xp_log.exists():
                params = read_json(xp_log)["raw_params"]
                write_json(params, params_file)
            else:
                write_json(params, params_file)

        self.watch_for_fitness(gen_folder)

    def watch_for_fitness(self, path):
        """
        Watches a specific folder for a fitness.json file
        Updates the algorithm with new fitnesses once found
        Appends the median fitnesses to the average

        Args:
            path (str): Folder to watch
        """

        fitness_path = path.joinpath(cst.FITNESS_FILE)
        self.logger.info(
            f'Waiting for fitness file in {path.as_posix()}.'
        )

        # Wait for the fitness file to be created
        while not fitness_path.exists():
            time.sleep(0.5)

        # Get the fitnesses and update the algorithm
        fitness_data = read_json(fitness_path)
        fitnesses = fitness_data["fitness"]
        self.algorithm.set_fitness_value(fitnesses)

        # Append the average of the fitnesses to the overall average
        avg = np.median(fitnesses)
        self.average_fitnesses.append(avg)

    def plot_fitness_curve(self, path):
        """
        Plots the median firness of the entire experiment

        Args:
            path (str): Root location of the XP
        """
        import matplotlib.pyplot as plt
        # self.logger.info(f'Plotting average fitness curve of {path}.')

        title = path.split("/")[-1:]
        plt.title("Median fitness of XP {}".format(title))
        plt.xlabel("Generations")
        plt.ylabel("Fitness")
        plt.plot(self.average_fitnesses)
        fig_name = str(self.info[cst.SEED]) + ".png"
        save_path = path.joinpath(fig_name)
        plt.savefig(save_path)

    def initialise(self):
        """
        Initialises the Creator to run for the total number of generations
        """
        total_generations = self.info[cst.GENS]
        for gen in range(total_generations):
            self.create_generation(gen)
        self.plot_fitness_curve(self.xp_path)
